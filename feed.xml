<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://rosemary-crypto.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rosemary-crypto.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-20T02:22:48+00:00</updated><id>https://rosemary-crypto.github.io/feed.xml</id><subtitle>Personal site for blog, projects, cv, etc. </subtitle><entry><title type="html">Getting Started with GStreamer Development – A Beginner’s Guide</title><link href="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/" rel="alternate" type="text/html" title="Getting Started with GStreamer Development – A Beginner’s Guide"/><published>2024-08-14T23:00:00+00:00</published><updated>2024-08-14T23:00:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="introduction">Introduction</h2> <p>Around a year and a half ago, I found myself tasked with rebuilding an AI video analytics platform. The goal? To transition it to use the GStreamer framework. At first, it seemed like an insurmountable challenge. I spent countless nights grappling with GStreamer’s intricacies—confused by the difference between a sink and a source, haunted by the complexities of GStreamer buffers. But as I pushed through, I started to see the beauty in it. I can’t believe I’m saying this, but GStreamer has made me fall deeper in love with C and C++.</p> <p>In this guide, I’ll introduce you to the basics of GStreamer, sharing what I’ve learned along the way to help you get started with building your own multimedia applications. Let’s dive in!</p> <h3 id="what-is-gstreamer">What is GStreamer?</h3> <p>GStreamer is a powerful multimedia framework used for building media processing pipelines. Whether you’re dealing with video, audio, or any other type of media, GStreamer provides the tools you need to manipulate and process data efficiently.</p> <p>At its core, GStreamer is built around the concept of pipelines—sequences of elements that process data from one end to another. These elements can be sources (e.g., reading from a file), filters (e.g., converting formats), or sinks (e.g., outputting to a display or speaker). Think of it as a factory assembly line, where raw materials (your media) are processed and refined at various stations (the elements), eventually leading to a finished product (your output).</p> <h3 id="what-am-i-using-gstreamer-for">What Am I Using GStreamer For?</h3> <p>For my AI video analytics platform, GStreamer acts as the backbone. The simplest version of the process is relatively straightforward: reading from a source (whether that’s video files, RTSP streams, etc.), performing object detection, tracking, and finally displaying the results. However, the full platform involves much more. It includes decoding the video streams, pre-processing the data, performing advanced object detection and tracking, video classification, adding custom metadata, sending data over MQTT, streaming via RTSP, and even detecting specific events. This complex pipeline allows for real-time analytics and decision-making, making GStreamer an essential tool in building this robust and scalable solution.</p> <p>You might wonder, “Why not just use something like NVIDIA’s DeepStream SDK?” It’s a valid question, and honestly, DeepStream could simplify things. But where’s the fun in that? GStreamer is open-source, allowing me to tweak and modify the code as needed. When existing plugins don’t meet my requirements, I have the freedom to build my own. This series is about giving you that same power: developing your own custom GStreamer elements for Linux, Windows, and macOS. So, let’s continue with the basics.</p> <h2 id="the-set-up">The Set-Up</h2> <h3 id="how-do-you-start">How Do You Start?</h3> <p>There’s no better place to understand GStreamer concepts than by exploring the <a href="https://gstreamer.freedesktop.org/documentation/application-development/?gi-language=c">GStreamer Application Development Manual</a>. It’s a treasure trove of information, and while I won’t repeat the concepts here, I’ll guide you through navigating everything, making your learning process smoother.</p> <h3 id="installing-gstreamer">Installing GStreamer</h3> <p>Before diving into examples, you’ll need to install GStreamer on your system. I suggest following the installation instructions in the <a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">GStreamer Application Development Manual</a> for your specific environment, whether that’s Linux, Windows, or macOS.</p> <h2 id="creating-a-simple-pipeline">Creating a Simple Pipeline</h2> <p>To understand GStreamer, it’s crucial to get hands-on experience. Let’s start by creating a simple pipeline to display a video.</p> <h3 id="pipeline-diagram">Pipeline Diagram</h3> <p><img src="/assets/img/build_with_gstreamer/basic-pipeline-lesson-1.png" alt="Pipeline Diagram"/></p> <p>This diagram shows a simple pipeline with elements like <code class="language-plaintext highlighter-rouge">filesrc</code>, <code class="language-plaintext highlighter-rouge">decodebin</code>, and <code class="language-plaintext highlighter-rouge">autovideosink</code> connected together.</p> <h3 id="understanding-the-basics">Understanding the Basics</h3> <ul> <li><strong>Elements:</strong> These are the basic building blocks of a GStreamer pipeline. Each element has a specific role, such as reading data (source), processing it (filter), or outputting it (sink). For example: <ul> <li><code class="language-plaintext highlighter-rouge">filesrc</code>: Reads data from a file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the data.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> </ul> </li> <li> <p><strong>Pads:</strong> A pad is a point of connection in a GStreamer element, where media data flows in or out. Every element has two types of pads: source pads (where data exits the element) and sink pads (where data enters). This concept mirrors real-world scenarios—a water faucet (source) provides water, while a drain (sink) receives it.</p> </li> <li> <p><strong>Bins:</strong> A bin is a container for elements. It groups multiple elements together, managing them as a single entity. This is particularly useful when dealing with complex pipelines. For example, <code class="language-plaintext highlighter-rouge">decodebin</code> is a bin because it automatically detects the format of incoming data, creates the necessary elements to decode it, and manages them internally. You don’t have to worry about what’s inside; it’s like a black box that simplifies your pipeline design.</p> </li> <li><strong>Pipelines:</strong> A pipeline is a special type of bin that manages the flow of data between elements. It controls the state of the elements and ensures data flows correctly from source to sink. Pipelines can contain multiple elements and bins, working together to process and deliver media.</li> </ul> <h3 id="command-line">Command Line</h3> <p>Let’s create the pipeline shown in the diagram using GStreamer’s command-line tool:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gst-launch-1.0 filesrc <span class="nv">location</span><span class="o">=</span>/path/to/video.mp4 <span class="o">!</span> decodebin <span class="o">!</span> autovideosink
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">filesrc location=/path/to/video.mp4</code>: This element reads the video file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the video format.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> <li><code class="language-plaintext highlighter-rouge">gst-launch-1.0</code>: A command-line tool provided by GStreamer to run pipelines.</li> <li><code class="language-plaintext highlighter-rouge">!</code>: Links elements together within the pipeline.</li> </ul> <h3 id="writing-the-equivalent-gstreamer-application-in-c">Writing the Equivalent GStreamer Application in C++</h3> <p>While using the command line is great for quick tests, writing your own applications using GStreamer’s API is where the real fun begins. Below is the part of the code to create a basic video player in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">GMainLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">;</span>
    <span class="n">GstBus</span><span class="o">*</span> <span class="n">bus</span><span class="p">;</span>
    <span class="n">guint</span> <span class="n">bus_watch_id</span><span class="p">;</span>

    <span class="c1">// Initialize GStreamer</span>
    <span class="n">gst_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

    <span class="c1">// Create a main loop, which will run until we explicitly quit</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">g_main_loop_new</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

    <span class="c1">// Create the elements</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">gst_pipeline_new</span><span class="p">(</span><span class="s">"video-player"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">source</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"filesrc"</span><span class="p">,</span> <span class="s">"file-source1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"decodebin"</span><span class="p">,</span> <span class="s">"decode-bin1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">autovideosink</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"autovideosink"</span><span class="p">,</span> <span class="s">"video-output1"</span><span class="p">);</span>

    <span class="c1">// Check that all elements were created successfully</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipeline</span> <span class="o">||</span> <span class="o">!</span><span class="n">source</span> <span class="o">||</span> <span class="o">!</span><span class="n">decoder</span> <span class="o">||</span> <span class="o">!</span><span class="n">autovideosink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Not all elements could be created.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the source file location</span>
    <span class="n">g_object_set</span><span class="p">(</span><span class="n">G_OBJECT</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s">"location"</span><span class="p">,</span> <span class="s">"../resources/videos/big_buck_bunny_scene.mp4"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Add all elements to the pipeline</span>
    <span class="n">gst_bin_add_many</span><span class="p">(</span><span class="n">GST_BIN</span><span class="p">(</span><span class="n">pipeline</span><span class="p">),</span> <span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">autovideosink</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Link the source to the decoder (decoder will dynamically link to sink)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gst_element_link</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Source and decoder could not be linked.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">pipeline</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Connect the pad-added signal for the decoder</span>
    <span class="n">g_signal_connect</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="s">"pad-added"</span><span class="p">,</span> <span class="n">G_CALLBACK</span><span class="p">(</span><span class="n">on_pad_added</span><span class="p">),</span> <span class="n">autovideosink</span><span class="p">);</span>

    <span class="c1">// Set the pipeline to the playing state</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_PLAYING</span><span class="p">);</span>

    <span class="c1">// Start the main loop and wait until it is quit (e.g., via EOS or an error)</span>
    <span class="n">g_main_loop_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="c1">// Clean up: set the pipeline to NULL state, remove bus watch, and unref</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_NULL</span><span class="p">);</span>
    <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">GST_OBJECT</span><span class="p">(</span><span class="n">pipeline</span><span class="p">));</span>
    <span class="n">g_main_loop_unref</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Callback function to dynamically link pads</span>
<span class="kt">void</span> <span class="nf">on_pad_added</span><span class="p">(</span><span class="n">GstElement</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">GstPad</span><span class="o">*</span> <span class="n">new_pad</span><span class="p">,</span> <span class="n">GstElement</span><span class="o">*</span> <span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GstPad</span><span class="o">*</span> <span class="n">sink_pad</span> <span class="o">=</span> <span class="n">gst_element_get_static_pad</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="s">"sink"</span><span class="p">);</span>

    <span class="c1">// Check if the sink pad is already linked</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gst_pad_is_linked</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Attempt to link the newly created pad with the sink pad</span>
    <span class="n">GstPadLinkReturn</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">gst_pad_link</span><span class="p">(</span><span class="n">new_pad</span><span class="p">,</span> <span class="n">sink_pad</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GST_PAD_LINK_FAILED</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Type is '%s' but link failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> 
            <span class="n">gst_structure_get_name</span><span class="p">(</span><span class="n">gst_caps_get_structure</span><span class="p">(</span><span class="n">gst_pad_get_current_caps</span><span class="p">(</span><span class="n">new_pad</span><span class="p">),</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">gst_init</code>: Initializes GStreamer and parses any command-line arguments.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_factory_make</code>: Creates the elements used in the pipeline, such as the source, decoder, and video sink.</li> <li><code class="language-plaintext highlighter-rouge">gst_bin_add_many</code>: Adds all elements to the pipeline.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_link</code>: Links the source element to the decoder. The decoder will dynamically link to the video sink when it determines the correct format.</li> <li><code class="language-plaintext highlighter-rouge">g_signal_connect</code>: Connects the “pad-added” signal for the decoder, allowing the new pad to be linked to the sink dynamically.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to PLAYING to start processing and displaying the video.</li> <li><code class="language-plaintext highlighter-rouge">g_main_loop_run</code>: Runs the main loop, keeping the application alive until an error occurs or the video finishes.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to NULL, stopping all elements when finished.</li> <li><code class="language-plaintext highlighter-rouge">gst_object_unref</code>: Frees up resources when the application is done.</li> </ul> <h4 id="understanding-the-on_pad_added-function">Understanding the <code class="language-plaintext highlighter-rouge">on_pad_added</code> Function</h4> <p>In GStreamer, some elements, like <code class="language-plaintext highlighter-rouge">decodebin</code>, dynamically create pads during runtime based on the media stream they are processing. They can’t link all their pads at the beginning because they don’t know what streams they will encounter (e.g., a video file might contain both audio and video streams).<br/> The <code class="language-plaintext highlighter-rouge">on_pad_added</code> function is a callback that gets triggered when the <code class="language-plaintext highlighter-rouge">decodebin</code> element adds a new pad. This is crucial because you need to link this newly created pad to the next element in your pipeline (in this case, <code class="language-plaintext highlighter-rouge">autovideosink</code>), which handles the video output.</p> <p>The complete code and detailed explanations, including installation instructions and how to run the program, are available on <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub</a>. This repository will be updated with each article in the series, making it easier for you to follow along.</p> <h3 id="github-repository-and-following-along">GitHub Repository and Following Along</h3> <p>To make the learning process even more interactive, I’ve created a <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a> where you can find all the code examples discussed in this series. Each module in this tutorial will be represented by a separate branch in the repository, allowing you to check out the specific branch to follow along with that module. As the course progresses, the <code class="language-plaintext highlighter-rouge">master</code> branch will be updated with the latest version of the project.</p> <ul> <li><strong>Start with Module 1:</strong> Check out the branch <code class="language-plaintext highlighter-rouge">lesson-1-getting-started</code> to see the code and examples for this introductory lesson.</li> <li><strong>Stay Updated:</strong> As you progress through the series, switch to the corresponding branch for each module to get the most relevant code and updates.</li> <li><strong>Explore the Code:</strong> Feel free to explore, modify, and experiment with the code in each branch to reinforce your learning.</li> </ul> <h3 id="compiling-and-running">Compiling and Running</h3> <p>Save the code to a file named <code class="language-plaintext highlighter-rouge">simple_player.cpp</code>. Then, compile it using <code class="language-plaintext highlighter-rouge">gcc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc simple_player.cpp <span class="nt">-o</span> simple_player <span class="si">$(</span>pkg-config <span class="nt">--cflags</span> <span class="nt">--libs</span> gstreamer-1.0<span class="si">)</span>
</code></pre></div></div> <p>Finally, run the compiled program:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./simple_player
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>This guide has introduced you to the basics of GStreamer, from understanding its architecture to creating a simple pipeline and writing a basic video player in C++. GStreamer is a powerful tool for multimedia development, offering the flexibility to build both simple and complex media applications.</p> <p>In the upcoming articles, we’ll explore GStreamer plugins in greater detail, including how to develop custom plugins for your specific needs—whether you’re aiming to build a media player, a streaming server, or an AI video analytics platform.</p> <h3 id="next-steps">Next Steps</h3> <ul> <li><strong>Access the Code:</strong> All the code examples, detailed explanations, and installation instructions are available in the <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a>. Make sure to check it out to follow along with each article in the series.</li> <li><strong>Experiment:</strong> Try experimenting with different GStreamer elements and building more complex pipelines.</li> <li><strong>Explore the Documentation:</strong> Dive into the GStreamer documentation to explore additional features and plugins.</li> <li><strong>Stay Tuned:</strong> Look forward to the next article, where we’ll discuss GStreamer plugins and how they work.</li> </ul>]]></content><author><name></name></author><category term="tutorials"/><category term="GStreamer,"/><category term="development,"/><category term="C++,"/><category term="AI,"/><category term="video"/><category term="analytics"/><summary type="html"><![CDATA[An introduction to GStreamer for building multimedia applications.]]></summary></entry></feed>