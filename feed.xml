<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://rosemary-crypto.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rosemary-crypto.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-23T09:42:01+00:00</updated><id>https://rosemary-crypto.github.io/feed.xml</id><title type="html">Rosemary Koikara - Cryptography, Blockchain, and AI Enthusiast</title><subtitle>Personal site for blog, projects, cv, etc. </subtitle><entry><title type="html">Lattice-Based Threshold Signature Schemes</title><link href="https://rosemary-crypto.github.io/blog/2024/lattice-based-threshold-signature-schemes/" rel="alternate" type="text/html" title="Lattice-Based Threshold Signature Schemes"/><published>2024-09-22T15:12:00+00:00</published><updated>2024-09-22T15:12:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/lattice-based-threshold-signature-schemes</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/lattice-based-threshold-signature-schemes/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="introduction-to-lattice-based-threshold-signature-schemes">Introduction to Lattice-Based Threshold Signature Schemes</h2> <p>Imagine you’re working in a blockchain network, and you don’t want one person to have full control of the private key needed to sign transactions. That sounds risky, right? Well, this is where <strong>threshold signature schemes</strong> (TSS) come into play. Instead of one person holding the key, multiple participants each hold a piece of it. And here’s the twist: none of them can reconstruct the entire key on their own. But when they work together, they can still sign a valid transaction or document. I’ve written about them <a href="https://rosemary-crypto.github.io/posts/introduction-to-threshold-signature-schemes/">here</a> if you’re interested in learning more about them.</p> <p>Now, let’s add <strong>lattice-based cryptography</strong> into the mix. Why? Because lattices, with their quantum-resilient properties, are a superhero of cryptography. Lattice-based cryptography is super secure and, unlike traditional methods, isn’t vulnerable to attacks from quantum computers.</p> <p>In this article, we’re going to break down how <strong>lattice-based threshold signatures</strong> work and how they could be used in real-world applications like blockchain.</p> <hr/> <h2 id="what-makes-lattice-based-cryptography-so-special">What makes Lattice-Based Cryptography so special?</h2> <p>Lattice-based cryptography is built on mathematical structures called <strong>lattices</strong>—essentially grids of points in space. What makes lattices special is that some problems related to them (the Shortest Vector Problem (SVP) and the Learning With Errors (LWE) problems)are incredibly hard to solve, even for quantum computers! This makes them a go-to choice for post-quantum cryptographic systems.</p> <p>In a lattice-based threshold signature scheme, the key (or secret) is hidden using these lattice-based problems. And just like in traditional TSS, no single participant can reveal the whole secret.</p> <hr/> <h2 id="how-does-lattice-based-tss-work">How Does Lattice-Based TSS Work?</h2> <p>Let’s break it down in simple terms:</p> <h3 id="distributed-key-generation-dkeygen">Distributed Key Generation (DKeyGen)</h3> <p>In the DKeyGen process, the secret key is split into <strong>t-out-of-n shares</strong>. So if you have a group of participants, you can decide that at least <em>t</em> of them need to cooperate to produce a signature. And don’t worry, the public key is still valid for verifying signatures—just like any other signature scheme.</p> <h3 id="share-refreshment-sharerefresh">Share Refreshment (ShareRefresh)</h3> <p>To keep things secure, we can periodically <strong>refresh</strong> the shares. That way, if someone tries to collect information over time, they’ll get stuck with useless, old data. It’s like giving your system a security refresh without changing the underlying secret!</p> <h3 id="distributed-signing-dsign">Distributed Signing (DSign)</h3> <p>Once the participants have their shares of the secret key, they can each sign parts of a message. When combined, these <strong>partial signatures</strong> form a complete, valid signature. The key advantage here is that no one participant can sign anything on their own, but together they can create a fully verifiable signature.</p> <hr/> <h2 id="where-can-we-use-lattice-based-tss">Where Can We Use Lattice-Based TSS?</h2> <p>Now that we have a basic understanding of how it works, let’s talk about real-world applications.</p> <h3 id="multisignature-wallets-in-blockchain">Multisignature Wallets in Blockchain</h3> <p>Imagine a multisignature wallet in a blockchain network. You don’t want a single person controlling the private key that authorizes transactions. Instead, a group of trusted people each holds a piece of the private key. To sign a transaction, they need to work together. This enhances security and prevents any one person from making unauthorized moves.</p> <p>Lattice-based cryptography makes this even more powerful because it protects against future threats from quantum computers. That’s something traditional cryptographic schemes can’t do.</p> <h3 id="zero-knowledge-proofs-and-privacy">Zero-Knowledge Proofs and Privacy</h3> <p>Lattice-based cryptography is also great for <strong>zero-knowledge proofs</strong> (ZKPs), where you can prove something is true without revealing the details. Combine that with threshold signatures, and you have a system that’s not only secure but also privacy-preserving. It’s a perfect match for privacy-focused blockchain applications.</p> <hr/> <h2 id="implementation">Implementation</h2> <p>If you’re curious to see how lattice-based threshold signatures work under the hood, I’ve created a complete <strong>Python implementation</strong> of these concepts, loosely based on the paper <em>Efficient Lattice-Based Threshold Signatures with Functional Interchangeability</em>.</p> <p>You can check out the implementation in this <a href="https://github.com/rosemary-crypto/lattice-based-tss">GitHub repository</a>. The code walks you through distributed key generation, share refreshment, and distributed signing, so you can easily experiment with it and see how it could work for your own blockchain projects!</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>Lattice-based threshold signature schemes offer a powerful and secure way to distribute trust in decentralized systems like blockchain. By splitting the private key across multiple participants and using lattice-based cryptography to enhance security, we can protect against both current and future threats, including quantum attacks.</p> <p>Whether you’re building a multisignature wallet, exploring zero-knowledge proofs, or simply interested in post-quantum cryptography, lattice-based TSS is an exciting area to dive into. And with the implementation linked in the GitHub repository, you can start exploring this cutting-edge cryptographic technique today!</p> <hr/> <h3 id="references">References</h3> <ol> <li>Tang et al., Efficient Lattice-Based Threshold Signatures with Functional Interchangeability. 2024.</li> </ol>]]></content><author><name></name></author><category term="cryptography"/><category term="cryptography,"/><category term="threshold"/><category term="signatures,"/><category term="lattice-based"/><category term="cryptography,"/><category term="blockchain"/><summary type="html"><![CDATA[An introduction to lattice-based threshold signatures, their applications, and a Python implementation.]]></summary></entry><entry><title type="html">Introduction to Threshold Signature Schemes</title><link href="https://rosemary-crypto.github.io/blog/2024/introduction-to-threshold-signature-schemes/" rel="alternate" type="text/html" title="Introduction to Threshold Signature Schemes"/><published>2024-09-19T15:12:00+00:00</published><updated>2024-09-19T15:12:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/introduction-to-threshold-signature-schemes</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/introduction-to-threshold-signature-schemes/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="introduction">Introduction</h2> <p>The idea of trusting a single person or system with <em>everything</em>—be it sensitive data, a secret, or even the keys to the kingdom—makes everyone a little nervous. What if they slip up? What if someone gets compromised? That’s where distributing the trust across multiple people or systems comes in handy.</p> <p>Enter <strong>Multiparty Computation (MPC)</strong> and <strong>Multiparty Key Management Systems (MKMS)</strong>. These cryptographic techniques allow multiple people to work together to perform tasks, like signing a document or approving a transaction, <em>without</em> any of them revealing their private information. It’s like having everyone contribute a piece of the puzzle, but no one person has all the pieces.</p> <p>We’re going to explore something called <strong>Threshold Signature Schemes (TSS)</strong>, a close relative of secret sharing (which we covered in a <a href="https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing/">previous post</a>), but with a twist: rather than simply protecting a secret, TSS lets a group of participants <em>collaborate</em> to generate a valid digital signature. And the coolest part? No one has the full private key.</p> <h2 id="what-is-tss">What is TSS?</h2> <p>So, what exactly is <strong>Threshold Signature Schemes (TSS)</strong>? Well, it’s all about splitting a private signing key into multiple pieces or shares, and only when a certain number of these shares (the threshold) come together can a valid signature be produced. Think of it like this: imagine you and your friends want to sign a really important document, but you don’t want just one person in charge of the pen. Instead, the pen is split into pieces, and only when enough pieces are put together can you write the signature. That’s TSS in a nutshell.</p> <p>Let’s take a practical example: you have a wallet in a decentralized exchange. Instead of one person holding the private key, TSS ensures that multiple parties hold <em>pieces</em> of that key. When it’s time to sign a transaction, a certain number of those people (the threshold) need to work together to create the signature.</p> <p>The beauty of TSS is that even though no one has the full private key, they can still collaborate to generate a valid signature. No single party holds too much power, but the system stays functional even if some shares are unavailable. It’s like teamwork, but for cryptography!</p> <h2 id="the-math-behind-tss-elliptic-curve-cryptography">The Math Behind TSS: Elliptic Curve Cryptography</h2> <p>Now we’re going to dive a bit deeper into the math behind TSS. This will help you understand how TSS works and why it’s secure.</p> <h3 id="what-is-elliptic-curve-cryptography-ecc">What is Elliptic Curve Cryptography (ECC)?</h3> <p><strong>Elliptic Curve Cryptography (ECC)</strong> is a type of public-key cryptography based on the algebraic structure of elliptic curves over finite fields. ECC allows for smaller keys compared to other cryptosystems like RSA while providing the same level of security. This efficiency makes ECC widely used in modern cryptography.</p> <p>An <strong>elliptic curve</strong> is defined by an equation of the form:</p> \[y^2 = x^3 + ax + b\] <p>where \(a\) and \(b\) are constants that satisfy the condition \(4a^3 + 27b^2 \neq 0\) to ensure that the curve has no singularities (i.e., it is smooth).</p> <p>In ECC, we work over a <strong>finite field</strong>, which means we only use integer coordinates within a certain range (modulo a prime number \(p\)). This ensures that there are a finite number of points on the curve, making computations feasible for cryptographic purposes.</p> <h3 id="basic-operations-on-elliptic-curves">Basic Operations on Elliptic Curves</h3> <p>The primary operation in ECC is <strong>point addition</strong>:</p> <ul> <li> <p><strong>Point Addition (\(P + Q\))</strong>: Given two points \(P\) and \(Q\) on the curve, their sum \(R = P + Q\) is also a point on the curve, defined by specific algebraic formulas.</p> </li> <li> <p><strong>Point Doubling (\(2P\))</strong>: This is a special case of point addition where \(P = Q\).</p> </li> </ul> <p>These operations are used to define <strong>scalar multiplication</strong>:</p> <ul> <li><strong>Scalar Multiplication (\(kP\))</strong>: This means adding the point \(P\) to itself \(k\) times. Scalar multiplication is computationally easy in one direction but hard to reverse, which is the basis for ECC’s security.</li> </ul> <h3 id="ecc-in-cryptography">ECC in Cryptography</h3> <p>In ECC-based cryptography, we have:</p> <ul> <li> <p><strong>Private Key (\(s\))</strong>: A randomly selected integer within a certain range.</p> </li> <li> <p><strong>Public Key (\(P\))</strong>: Calculated as \(P = sG\), where \(G\) is a predefined generator point on the elliptic curve.</p> </li> </ul> <p>The security of ECC comes from the <strong>Elliptic Curve Discrete Logarithm Problem (ECDLP)</strong>: Given \(P\) and \(G\), it’s computationally infeasible to determine \(s\).</p> <h3 id="how-tss-utilizes-ecc">How TSS Utilizes ECC</h3> <p>In Threshold Signature Schemes, ECC is used to allow multiple participants to collaborate on signing a message without revealing their individual private keys.</p> <h4 id="key-generation-in-tss-ecc-based">Key Generation in TSS (ECC-based)</h4> <ol> <li> <p><strong>Private Key Sharing</strong>:</p> <ul> <li> <p>The original private key \(s\) is split into \(n\) shares \(s_1, s_2, \dots, s_n\) using a secret sharing scheme (like Shamir’s Secret Sharing).</p> </li> <li> <p>Each participant \(i\) holds a share \(s_i\).</p> </li> </ul> </li> <li> <p><strong>Public Key Computation</strong>:</p> <ul> <li> <p>The public key remains \(P = sG\).</p> </li> <li> <p>Each participant can compute their own public share \(P_i = s_i G\).</p> </li> </ul> </li> </ol> <h4 id="signature-generation">Signature Generation</h4> <p>When a message \(m\) needs to be signed:</p> <ol> <li> <p><strong>Partial Signatures</strong>:</p> <ul> <li> <p>Each participant computes a partial signature \(\sigma_i\) using their private share \(s_i\).</p> </li> <li> <p>The signature process involves generating a random nonce \(k_i\) and computing \(R_i = k_i G\).</p> </li> </ul> </li> <li> <p><strong>Combining Partial Signatures</strong>:</p> <ul> <li> <p>The participants broadcast their \(R_i\) values and use them to compute a combined \(R\).</p> </li> <li> <p>They then use their \(s_i\) and \(k_i\) to compute their partial signatures \(\sigma_i\).</p> </li> </ul> </li> <li> <p><strong>Final Signature</strong>:</p> <ul> <li>The partial signatures \(\sigma_i\) are combined using Lagrange interpolation to produce the final signature \(\sigma\).</li> </ul> </li> </ol> <h4 id="signature-verification">Signature Verification</h4> <p>The final signature \(\sigma\) can be verified using the public key \(P\) and the combined \(R\):</p> \[sG = R + eP\] <p>where \(e\) is the hash of the message and \(R\).</p> <h3 id="why-ecc-is-suitable-for-tss">Why ECC is Suitable for TSS</h3> <ul> <li> <p><strong>Efficiency</strong>: ECC allows for smaller keys and faster computations compared to other cryptographic systems.</p> </li> <li> <p><strong>Security</strong>: The hardness of the ECDLP ensures that even if an attacker obtains partial information, they cannot reconstruct the private key.</p> </li> <li> <p><strong>Scalability</strong>: ECC-based TSS can handle a large number of participants without significant performance degradation.</p> </li> </ul> <h3 id="want-to-see-ecc-in-action">Want to See ECC in Action?</h3> <p>If you’re interested in seeing a practical implementation of ECC and how it integrates with TSS, check out this <a href="https://github.com/rosemary-crypto/ECC-TSS-Demo">GitHub repository</a>. There, you’ll find code examples that walk you through:</p> <ul> <li>Generating elliptic curves and keys.</li> <li>Performing point addition and scalar multiplication.</li> <li>Implementing TSS using ECC, including key sharing, partial signature generation, and signature verification.</li> </ul> <p>By exploring the code, you’ll gain a deeper understanding of how ECC works under the hood and how it powers Threshold Signature Schemes.</p> <h2 id="choosing-the-right-tss-protocol">Choosing the Right TSS Protocol</h2> <p>There’s no one-size-fits-all TSS protocol. Depending on what you’re trying to do, different variations of TSS might be more suitable. Here are a few popular ones:</p> <ol> <li><strong>Shamir-based TSS</strong>: <ul> <li><strong>Strengths</strong>: Simple, easy to implement, and mathematically elegant.</li> <li><strong>Weaknesses</strong>: If all shares are gathered, the private key can be reconstructed, which might pose a security risk.</li> </ul> </li> <li><strong>Pedersen’s TSS</strong>: <ul> <li><strong>Strengths</strong>: Uses verifiable secret sharing to ensure that malicious participants can’t provide false shares.</li> <li><strong>Weaknesses</strong>: A bit more computationally intensive, but worth it if you need the added security.</li> </ul> </li> <li><strong>Feldman’s TSS</strong>: <ul> <li><strong>Strengths</strong>: Adds public verification, so you can easily check if shares are valid without revealing anything sensitive.</li> <li><strong>Weaknesses</strong>: Like Pedersen’s, it’s more computationally demanding than Shamir’s, but it’s also more secure.</li> </ul> </li> </ol> <p>Each protocol comes with its own balance of security and computational complexity, so the right one depends on your specific needs.</p> <h2 id="real-world-applications-of-tss">Real-World Applications of TSS</h2> <p>Now that you have a grasp on how TSS works, let’s talk about where it’s being used today.</p> <h3 id="1-blockchain-and-decentralized-finance-defi">1. Blockchain and Decentralized Finance (DeFi)</h3> <p>In platforms like Bitcoin and Ethereum, TSS is used to manage multi-signature wallets. With TSS, multiple parties must approve a transaction before it can be executed, making it a perfect solution for secure fund management.</p> <h3 id="2-secure-voting-systems">2. Secure Voting Systems</h3> <p>In some e-voting systems, TSS allows a group of voters to securely sign off on a decision without revealing individual votes. It’s a great way to ensure that everyone has a say without compromising privacy.</p> <h3 id="3-distributed-key-management">3. Distributed Key Management</h3> <p>In cloud environments, TSS allows multiple servers or entities to manage cryptographic keys without any one server having the full key. This prevents key exposure and enhances overall security.</p> <h3 id="4-privacy-preserving-protocols">4. Privacy-Preserving Protocols</h3> <p>TSS is also crucial for privacy-preserving systems, like secure multiparty computation (SMPC), where parties work together to compute a function without revealing their individual inputs.</p> <h2 id="security-and-efficiency-what-to-consider">Security and Efficiency: What to Consider</h2> <p>TSS gives you a ton of security advantages, but as always, there are trade-offs to keep in mind:</p> <h3 id="security-advantages">Security Advantages:</h3> <ul> <li><strong>No Single Point of Failure</strong>: Even if some participants are compromised, the system stays secure unless the threshold is met.</li> <li><strong>Distributed Trust</strong>: TSS distributes control among multiple parties, reducing the risk of any one person holding too much power.</li> <li><strong>Collusion Resistance</strong>: With verifiable secret sharing, participants can’t lie about their shares without being caught.</li> </ul> <h3 id="efficiency-considerations">Efficiency Considerations:</h3> <ul> <li><strong>Computational Overhead</strong>: Generating and combining signatures is more computationally expensive than traditional methods.</li> <li><strong>Communication Overhead</strong>: Participants need to communicate to share their pieces, which can add some delay, especially in large systems.</li> </ul> <p>Balancing security and efficiency is key when deciding how to implement TSS in a large-scale system.</p> <h2 id="conclusion">Conclusion</h2> <p>So there you have it! <strong>Threshold Signature Schemes (TSS)</strong> are an incredible tool in the cryptography world, offering the best of both security and distributed trust. Whether you’re building a decentralized finance platform, a secure voting system, or managing cryptographic keys in the cloud, TSS can help protect your system from single points of failure and enhance overall security.</p> <p>Remember, understanding the math behind these concepts can deepen your grasp of how they work and why they’re secure. If you want to explore ECC and TSS in more detail, including practical code examples, feel free to check out the <a href="https://github.com/rosemary-crypto/ECC-TSS-Demo">GitHub repository</a>. It’s a great resource to see these principles in action.</p> <p>Happy coding and stay secure!</p>]]></content><author><name></name></author><category term="cryptography"/><category term="cryptography,"/><category term="TSS,"/><category term="distributed"/><category term="systems"/><summary type="html"><![CDATA[An introduction to Threshold Signature Schemes and their practical applications]]></summary></entry><entry><title type="html">Introduction to Secret Sharing</title><link href="https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing/" rel="alternate" type="text/html" title="Introduction to Secret Sharing"/><published>2024-08-20T15:12:00+00:00</published><updated>2024-08-20T15:12:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="secret-sharing">Secret Sharing</h2> <p>I wouldn’t call myself a secretive person, but I do value my privacy. If you’re like me, you’ve probably found yourself holding onto a secret so tightly that you start feeling like it might just burst out. But instead of spilling the whole thing to one person, you decide to share bits and pieces with different people. This way, no single person knows the full story, and you feel a bit more secure.</p> <p>Secret sharing works in a similar way. Introduced by Adi Shamir and George Blakley independently in 1979 (yes, it’s been around for a while, but like a good classic, it’s still relevant), secret sharing is all about distributing a secret among a group of participants. The twist? No single participant has any meaningful information on their own. However, when a sufficient number of these participants come together, they can reconstruct the original secret.</p> <p>In this post, we’ll explore Shamir’s version of secret sharing, a powerful cryptographic tool that splits a secret into pieces, or “shares.” These shares are individually useless, but when you have enough of them (we’ll call this number the threshold), you can piece together the original secret.</p> <h2 id="mathematical-definition-of-shamirs-secret-sharing">Mathematical Definition of Shamir’s Secret Sharing</h2> <p>Let’s get a bit more technical. SSS is sometimes referred to as the \((k, n)\) threshold secret sharing scheme. Here, \(n\) is the number of shares into which the secret is divided, and \(k\) is the minimum number of shares required to reconstruct the secret. Essentially, \(k\) participants must come together to unlock the secret. If you have fewer than \(k\) shares, you’re out of luck; the secret remains hidden.</p> <p>But how does this actually work? The secret is hidden inside a mathematical function called a polynomial. A polynomial is just a mathematical expression involving a sum of powers of \(x\) multiplied by coefficients. In Shamir’s scheme, we use a polynomial of degree \(k-1\), which ensures that any group of \(k\) or more participants can reconstruct the secret.</p> \[f(x) = s_0 + s_1x + \dots + s_{k-1}x^{k-1} \mod p\] <p>Lagrange’s interpolation can be used to reconstruct the secret. The Lagrange interpolation formula for reconstructing the polynomial (and thus the secret) from these shares is:</p> \[q(x) = \sum_{i=1}^{k} y_i \cdot L_i(x)\] <p>where \(y_i\) are the share values, and \(L_i(x)\) are the Lagrange basis polynomials, defined as:</p> \[L_i(x) = \prod_{\substack{1 \le j \le k \\ j \ne i}} \frac{x - x_j}{x_i - x_j}\] <h2 id="why-modular-arithmetic-and-prime-numbers">Why Modular Arithmetic and Prime Numbers?</h2> <ul> <li> <p><strong>Modular arithmetic</strong> is a system of arithmetic for integers, where numbers wrap around after they reach a certain value, \(p\) (the modulus). Think of it like a clock: after 12 comes 1 again. In cryptography, modular arithmetic helps keep numbers within a specific range, making it more manageable and secure.</p> </li> <li> <p><strong>Prime numbers</strong> are crucial because they ensure certain properties that are vital for cryptographic security:</p> <ul> <li><strong>Unique Inverses</strong>: In modular arithmetic with a prime modulus \(p\), every non-zero number has a unique multiplicative inverse. This means that for any non-zero number \(a\) within the range \([1, p-1]\), there exists a number \(b\) such that \((a \cdot b) \mod p = 1\). This property is crucial because it allows division operations to be performed in modular arithmetic.</li> <li><strong>Avoiding Redundancies</strong>: Prime moduli help avoid redundancies and ensure that every possible result of an operation is unique within the range \([0, p-1]\). This uniqueness is critical in cryptography because it prevents different numbers from being treated as equivalent, which could otherwise lead to vulnerabilities.</li> <li><strong>Mathematical Stability</strong>: Using a prime number ensures that the structure of the arithmetic remains stable, making it easier to predict and manage the behavior of calculations, which is why primes are often used in cryptographic protocols.</li> </ul> </li> </ul> <h2 id="basic-example-with-numbers">Basic Example with Numbers</h2> <p>Let’s start simple. Imagine you have a secret number, and you want to split it among five people so that any three of them can come together and recover it. You’ll create a polynomial, and each person gets a point on this polynomial as their share. Only when three or more people pool their points together can they figure out what the original number (the secret) was.</p> <h3 id="generating-the-shares">Generating the Shares</h3> <p>Let’s take a \((2, 5)\) threshold scheme to divide the secret 298 and let the prime number be 307. (I chose 307 since it is a prime number larger than 298)</p> <ol> <li><strong>Set up the polynomial</strong> <ul> <li>Degree: \(k-1 = 1\)</li> <li>Form: \(q(x) = s + a_1 \cdot x \mod p = 298 + a_1 \cdot x \mod 307\)</li> </ul> </li> <li> <p><strong>Choose a random coefficient</strong> \(a_1\) in the range \([0, p)\). Let’s choose \(a_1 = 123\).</p> </li> <li><strong>Calculate the shares</strong>: Now, we can calculate the shares at 5 non-zero points \(x = 1, 2, 3, 4, 5\) as: <ul> <li>Share 1: \((1, 114)\)</li> <li>Share 2: \((2, 237)\)</li> <li>Share 3: \((3, 53)\)</li> <li>Share 4: \((4, 176)\)</li> <li>Share 5: \((5, 299)\)</li> </ul> </li> </ol> <p>You now have 5 shares: \((1, 114), (2, 237), (3, 53), (4, 176), (5, 299)\).</p> <h3 id="reconstructing-the-secret-using-lagrange-interpolation">Reconstructing the Secret Using Lagrange Interpolation</h3> <p>Let’s now reconstruct the secret using Lagrange interpolation. Since this is a \((2, 5)\) threshold scheme, we need only two of the shares to reconstruct the secret. We’ll use Share 1 \((1, 114)\) and Share 2 \((2, 237)\).</p> <ol> <li><strong>Calculate the Lagrange basis</strong> <ul> <li>For our example, with \(x_1 = 1\) and \(x_2 = 2\), the Lagrange basis polynomials at \(x = 0\) (which gives us the secret) are:</li> </ul> \[L_1(0) = \frac{0 - 2}{1 - 2} = \frac{-2}{-1} = 2\] \[L_2(0) = \frac{0 - 1}{2 - 1} = \frac{-1}{1} = -1\] </li> <li><strong>Calculate the Secret</strong> <ul> <li>Now, we use these Lagrange basis polynomials to reconstruct the secret:</li> </ul> \[q(0) = y_1 \cdot L_1(0) + y_2 \cdot L_2(0)\] <ul> <li>Substituting the values from the shares:</li> </ul> \[q(0) = 114 \cdot 2 + 237 \cdot (-1) = 228 - 237 = -9\] <ul> <li>Since we’re working in modular arithmetic with \(p = 307\), we take the result modulo 307:</li> </ul> \[q(0) = -9 \mod 307 = 298\] </li> </ol> <p>Thus, the reconstructed secret is \(s = 298\), which matches our original secret.</p> <h2 id="shamirs-secret-sharing-using-a-secret-image">Shamir’s Secret Sharing Using a Secret Image</h2> <p>To really bring this to life, let’s take it a step further. Instead of just splitting a number, let’s split an image. Lets take an example of (3,5) threshold secret sharing as shown in the figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/secret_sharing/3_5_SecretImageSharing-480.webp 480w,/assets/img/secret_sharing/3_5_SecretImageSharing-800.webp 800w,/assets/img/secret_sharing/3_5_SecretImageSharing-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/secret_sharing/3_5_SecretImageSharing.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> ((3,5) Threshold Secret Image Sharing) </div> <h3 id="how-it-works">How It Works</h3> <ul> <li> <p><strong>Image Splitting</strong>: Each pixel’s grayscale value in the image is treated as a secret. Shamir’s Secret Sharing algorithm is applied to split each pixel’s value into multiple shares. For instance, in a \((3,5)\) threshold scheme, the image is divided into 5 shares, but at least 3 shares are needed to reconstruct the image.</p> </li> <li> <p><strong>Share Generation</strong>: For each pixel, shares are generated based on a random polynomial where the pixel value is the constant term. These shares are then distributed, with each share forming part of a different image, each appearing as random noise.</p> </li> <li> <p><strong>Image Reconstruction</strong>: To reconstruct the image, a minimum of 3 shares are combined using Lagrange interpolation to recover the original pixel values and, thus, the entire image.</p> </li> </ul> <h3 id="code-implementation">Code Implementation</h3> <p>The complete implementation of this concept is provided in the repository. The code is available in both C++ and Rust:</p> <ul> <li><strong>C++ Version</strong>: <ul> <li>Located in the <code class="language-plaintext highlighter-rouge">cpp</code> directory, this version uses OpenCV for image processing.</li> </ul> </li> <li><strong>Rust Version</strong>: <ul> <li>Located in the <code class="language-plaintext highlighter-rouge">rust</code> directory.</li> </ul> </li> </ul> <p>The code is accessible on <a href="https://github.com/rosemary-crypto/Shamir-sSecretSharing">GitHub</a> for further exploration and application.</p> <h2 id="significance-in-modern-applications">Significance in Modern Applications</h2> <p>Now, why should you care about this old-school cryptography trick? Well, let’s dive into the world of Threshold Signature Schemes (TSS). Imagine you’re working on a distributed system, like a blockchain. In such systems, it’s crucial that a group of participants can collaboratively sign off on transactions or documents. But here’s the catch: you don’t want any single participant holding the entire signing key, because that’s a single point of failure and a potential security nightmare.</p> <p>TSS comes to the rescue by allowing a group of participants to generate a digital signature on a message without anyone holding the full key. Instead, the key is distributed, and only a subset of participants—what we call the threshold number—needs to come together to produce a valid signature. This method not only enhances security by eliminating single points of failure but also builds trust, as no single party controls the entire signing process.</p> <p>However, TSS is more complex than SSS, but that’s why we’re here. Before diving into TSS, it’s important to understand SSS and its limitations so we can appreciate the need for more advanced techniques like TSS.</p>]]></content><author><name></name></author><category term="cryptography"/><category term="cryptography,"/><category term="secret"/><category term="sharing,"/><category term="TSS"/><summary type="html"><![CDATA[An introduction to Shamir's Secret Sharing and its applications]]></summary></entry><entry><title type="html">Getting Started with GStreamer Development – A Beginner’s Guide</title><link href="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/" rel="alternate" type="text/html" title="Getting Started with GStreamer Development – A Beginner’s Guide"/><published>2024-08-14T23:00:00+00:00</published><updated>2024-08-14T23:00:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="introduction">Introduction</h2> <p>Around a year and a half ago, I found myself tasked with rebuilding an AI video analytics platform. The goal? To transition it to use the GStreamer framework. At first, it seemed like an insurmountable challenge. I spent countless nights grappling with GStreamer’s intricacies—confused by the difference between a sink and a source, haunted by the complexities of GStreamer buffers. But as I pushed through, I started to see the beauty in it. I can’t believe I’m saying this, but GStreamer has made me fall deeper in love with C and C++.</p> <p>In this guide, I’ll introduce you to the basics of GStreamer, sharing what I’ve learned along the way to help you get started with building your own multimedia applications. Let’s dive in!</p> <h3 id="what-is-gstreamer">What is GStreamer?</h3> <p>GStreamer is a powerful multimedia framework used for building media processing pipelines. Whether you’re dealing with video, audio, or any other type of media, GStreamer provides the tools you need to manipulate and process data efficiently.</p> <p>At its core, GStreamer is built around the concept of pipelines—sequences of elements that process data from one end to another. These elements can be sources (e.g., reading from a file), filters (e.g., converting formats), or sinks (e.g., outputting to a display or speaker). Think of it as a factory assembly line, where raw materials (your media) are processed and refined at various stations (the elements), eventually leading to a finished product (your output).</p> <h3 id="what-am-i-using-gstreamer-for">What Am I Using GStreamer For?</h3> <p>For my AI video analytics platform, GStreamer acts as the backbone. The simplest version of the process is relatively straightforward: reading from a source (whether that’s video files, RTSP streams, etc.), performing object detection, tracking, and finally displaying the results. However, the full platform involves much more. It includes decoding the video streams, pre-processing the data, performing advanced object detection and tracking, video classification, adding custom metadata, sending data over MQTT, streaming via RTSP, and even detecting specific events. This complex pipeline allows for real-time analytics and decision-making, making GStreamer an essential tool in building this robust and scalable solution.</p> <p>You might wonder, “Why not just use something like NVIDIA’s DeepStream SDK?” It’s a valid question, and honestly, DeepStream could simplify things. But where’s the fun in that? GStreamer is open-source, allowing me to tweak and modify the code as needed. When existing plugins don’t meet my requirements, I have the freedom to build my own. This series is about giving you that same power: developing your own custom GStreamer elements for Linux, Windows, and macOS. So, let’s continue with the basics.</p> <h2 id="the-set-up">The Set-Up</h2> <h3 id="how-do-you-start">How Do You Start?</h3> <p>There’s no better place to understand GStreamer concepts than by exploring the <a href="https://gstreamer.freedesktop.org/documentation/application-development/?gi-language=c">GStreamer Application Development Manual</a>. It’s a treasure trove of information, and while I won’t repeat the concepts here, I’ll guide you through navigating everything, making your learning process smoother.</p> <h3 id="installing-gstreamer">Installing GStreamer</h3> <p>Before diving into examples, you’ll need to install GStreamer on your system. I suggest following the installation instructions in the <a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">GStreamer Application Development Manual</a> for your specific environment, whether that’s Linux, Windows, or macOS.</p> <h2 id="creating-a-simple-pipeline">Creating a Simple Pipeline</h2> <p>To understand GStreamer, it’s crucial to get hands-on experience. Let’s start by creating a simple pipeline to display a video.</p> <h3 id="pipeline-diagram">Pipeline Diagram</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-480.webp 480w,/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-800.webp 800w,/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/build_with_gstreamer/basic-pipeline-lesson-1.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This diagram shows a simple pipeline with elements like <code class="language-plaintext highlighter-rouge">filesrc</code>, <code class="language-plaintext highlighter-rouge">decodebin</code>, and <code class="language-plaintext highlighter-rouge">autovideosink</code> connected together.</p> <h3 id="understanding-the-basics">Understanding the Basics</h3> <ul> <li><strong>Elements:</strong> These are the basic building blocks of a GStreamer pipeline. Each element has a specific role, such as reading data (source), processing it (filter), or outputting it (sink). For example: <ul> <li><code class="language-plaintext highlighter-rouge">filesrc</code>: Reads data from a file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the data.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> </ul> </li> <li> <p><strong>Pads:</strong> A pad is a point of connection in a GStreamer element, where media data flows in or out. Every element has two types of pads: source pads (where data exits the element) and sink pads (where data enters). This concept mirrors real-world scenarios—a water faucet (source) provides water, while a drain (sink) receives it.</p> </li> <li> <p><strong>Bins:</strong> A bin is a container for elements. It groups multiple elements together, managing them as a single entity. This is particularly useful when dealing with complex pipelines. For example, <code class="language-plaintext highlighter-rouge">decodebin</code> is a bin because it automatically detects the format of incoming data, creates the necessary elements to decode it, and manages them internally. You don’t have to worry about what’s inside; it’s like a black box that simplifies your pipeline design.</p> </li> <li><strong>Pipelines:</strong> A pipeline is a special type of bin that manages the flow of data between elements. It controls the state of the elements and ensures data flows correctly from source to sink. Pipelines can contain multiple elements and bins, working together to process and deliver media.</li> </ul> <h3 id="command-line">Command Line</h3> <p>Let’s create the pipeline shown in the diagram using GStreamer’s command-line tool:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gst-launch-1.0 filesrc <span class="nv">location</span><span class="o">=</span>/path/to/video.mp4 <span class="o">!</span> decodebin <span class="o">!</span> autovideosink
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">filesrc location=/path/to/video.mp4</code>: This element reads the video file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the video format.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> <li><code class="language-plaintext highlighter-rouge">gst-launch-1.0</code>: A command-line tool provided by GStreamer to run pipelines.</li> <li><code class="language-plaintext highlighter-rouge">!</code>: Links elements together within the pipeline.</li> </ul> <h3 id="writing-the-equivalent-gstreamer-application-in-c">Writing the Equivalent GStreamer Application in C++</h3> <p>While using the command line is great for quick tests, writing your own applications using GStreamer’s API is where the real fun begins. Below is the part of the code to create a basic video player in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">GMainLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">;</span>
    <span class="n">GstBus</span><span class="o">*</span> <span class="n">bus</span><span class="p">;</span>
    <span class="n">guint</span> <span class="n">bus_watch_id</span><span class="p">;</span>

    <span class="c1">// Initialize GStreamer</span>
    <span class="n">gst_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

    <span class="c1">// Create a main loop, which will run until we explicitly quit</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">g_main_loop_new</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

    <span class="c1">// Create the elements</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">gst_pipeline_new</span><span class="p">(</span><span class="s">"video-player"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">source</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"filesrc"</span><span class="p">,</span> <span class="s">"file-source1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"decodebin"</span><span class="p">,</span> <span class="s">"decode-bin1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">autovideosink</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"autovideosink"</span><span class="p">,</span> <span class="s">"video-output1"</span><span class="p">);</span>

    <span class="c1">// Check that all elements were created successfully</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipeline</span> <span class="o">||</span> <span class="o">!</span><span class="n">source</span> <span class="o">||</span> <span class="o">!</span><span class="n">decoder</span> <span class="o">||</span> <span class="o">!</span><span class="n">autovideosink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Not all elements could be created.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the source file location</span>
    <span class="n">g_object_set</span><span class="p">(</span><span class="n">G_OBJECT</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s">"location"</span><span class="p">,</span> <span class="s">"../resources/videos/big_buck_bunny_scene.mp4"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Add all elements to the pipeline</span>
    <span class="n">gst_bin_add_many</span><span class="p">(</span><span class="n">GST_BIN</span><span class="p">(</span><span class="n">pipeline</span><span class="p">),</span> <span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">autovideosink</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Link the source to the decoder (decoder will dynamically link to sink)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gst_element_link</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Source and decoder could not be linked.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">pipeline</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Connect the pad-added signal for the decoder</span>
    <span class="n">g_signal_connect</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="s">"pad-added"</span><span class="p">,</span> <span class="n">G_CALLBACK</span><span class="p">(</span><span class="n">on_pad_added</span><span class="p">),</span> <span class="n">autovideosink</span><span class="p">);</span>

    <span class="c1">// Set the pipeline to the playing state</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_PLAYING</span><span class="p">);</span>

    <span class="c1">// Start the main loop and wait until it is quit (e.g., via EOS or an error)</span>
    <span class="n">g_main_loop_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="c1">// Clean up: set the pipeline to NULL state, remove bus watch, and unref</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_NULL</span><span class="p">);</span>
    <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">GST_OBJECT</span><span class="p">(</span><span class="n">pipeline</span><span class="p">));</span>
    <span class="n">g_main_loop_unref</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Callback function to dynamically link pads</span>
<span class="kt">void</span> <span class="nf">on_pad_added</span><span class="p">(</span><span class="n">GstElement</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">GstPad</span><span class="o">*</span> <span class="n">new_pad</span><span class="p">,</span> <span class="n">GstElement</span><span class="o">*</span> <span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GstPad</span><span class="o">*</span> <span class="n">sink_pad</span> <span class="o">=</span> <span class="n">gst_element_get_static_pad</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="s">"sink"</span><span class="p">);</span>

    <span class="c1">// Check if the sink pad is already linked</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gst_pad_is_linked</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Attempt to link the newly created pad with the sink pad</span>
    <span class="n">GstPadLinkReturn</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">gst_pad_link</span><span class="p">(</span><span class="n">new_pad</span><span class="p">,</span> <span class="n">sink_pad</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GST_PAD_LINK_FAILED</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Type is '%s' but link failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">gst_structure_get_name</span><span class="p">(</span><span class="n">gst_caps_get_structure</span><span class="p">(</span><span class="n">gst_pad_get_current_caps</span><span class="p">(</span><span class="n">new_pad</span><span class="p">),</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">gst_init</code>: Initializes GStreamer and parses any command-line arguments.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_factory_make</code>: Creates the elements used in the pipeline, such as the source, decoder, and video sink.</li> <li><code class="language-plaintext highlighter-rouge">gst_bin_add_many</code>: Adds all elements to the pipeline.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_link</code>: Links the source element to the decoder. The decoder will dynamically link to the video sink when it determines the correct format.</li> <li><code class="language-plaintext highlighter-rouge">g_signal_connect</code>: Connects the “pad-added” signal for the decoder, allowing the new pad to be linked to the sink dynamically.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to PLAYING to start processing and displaying the video.</li> <li><code class="language-plaintext highlighter-rouge">g_main_loop_run</code>: Runs the main loop, keeping the application alive until an error occurs or the video finishes.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to NULL, stopping all elements when finished.</li> <li><code class="language-plaintext highlighter-rouge">gst_object_unref</code>: Frees up resources when the application is done.</li> </ul> <h4 id="understanding-the-on_pad_added-function">Understanding the <code class="language-plaintext highlighter-rouge">on_pad_added</code> Function</h4> <p>In GStreamer, some elements, like <code class="language-plaintext highlighter-rouge">decodebin</code>, dynamically create pads during runtime based on the media stream they are processing. They can’t link all their pads at the beginning because they don’t know what streams they will encounter (e.g., a video file might contain both audio and video streams).<br/> The <code class="language-plaintext highlighter-rouge">on_pad_added</code> function is a callback that gets triggered when the <code class="language-plaintext highlighter-rouge">decodebin</code> element adds a new pad. This is crucial because you need to link this newly created pad to the next element in your pipeline (in this case, <code class="language-plaintext highlighter-rouge">autovideosink</code>), which handles the video output.</p> <p>The complete code and detailed explanations, including installation instructions and how to run the program, are available on <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub</a>. This repository will be updated with each article in the series, making it easier for you to follow along.</p> <h3 id="github-repository-and-following-along">GitHub Repository and Following Along</h3> <p>To make the learning process even more interactive, I’ve created a <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a> where you can find all the code examples discussed in this series. Each module in this tutorial will be represented by a separate branch in the repository, allowing you to check out the specific branch to follow along with that module. As the course progresses, the <code class="language-plaintext highlighter-rouge">master</code> branch will be updated with the latest version of the project.</p> <ul> <li><strong>Start with Module 1:</strong> Check out the branch <code class="language-plaintext highlighter-rouge">lesson-1-getting-started</code> to see the code and examples for this introductory lesson.</li> <li><strong>Stay Updated:</strong> As you progress through the series, switch to the corresponding branch for each module to get the most relevant code and updates.</li> <li><strong>Explore the Code:</strong> Feel free to explore, modify, and experiment with the code in each branch to reinforce your learning.</li> </ul> <h3 id="compiling-and-running">Compiling and Running</h3> <p>Save the code to a file named <code class="language-plaintext highlighter-rouge">simple_player.cpp</code>. Then, compile it using <code class="language-plaintext highlighter-rouge">gcc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc simple_player.cpp <span class="nt">-o</span> simple_player <span class="si">$(</span>pkg-config <span class="nt">--cflags</span> <span class="nt">--libs</span> gstreamer-1.0<span class="si">)</span>
</code></pre></div></div> <p>Finally, run the compiled program:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./simple_player
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>This guide has introduced you to the basics of GStreamer, from understanding its architecture to creating a simple pipeline and writing a basic video player in C++. GStreamer is a powerful tool for multimedia development, offering the flexibility to build both simple and complex media applications.</p> <p>In the upcoming articles, we’ll explore GStreamer plugins in greater detail, including how to develop custom plugins for your specific needs—whether you’re aiming to build a media player, a streaming server, or an AI video analytics platform.</p> <h3 id="next-steps">Next Steps</h3> <ul> <li><strong>Access the Code:</strong> All the code examples, detailed explanations, and installation instructions are available in the <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a>. Make sure to check it out to follow along with each article in the series.</li> <li><strong>Experiment:</strong> Try experimenting with different GStreamer elements and building more complex pipelines.</li> <li><strong>Explore the Documentation:</strong> Dive into the GStreamer documentation to explore additional features and plugins.</li> <li><strong>Stay Tuned:</strong> Look forward to the next article, where we’ll discuss GStreamer plugins and how they work.</li> </ul>]]></content><author><name></name></author><category term="tutorials"/><category term="GStreamer,"/><category term="development,"/><category term="C++,"/><category term="AI,"/><category term="video"/><category term="analytics"/><summary type="html"><![CDATA[An introduction to GStreamer for building multimedia applications.]]></summary></entry></feed>