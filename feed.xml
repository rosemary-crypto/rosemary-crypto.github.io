<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://rosemary-crypto.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rosemary-crypto.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-23T08:49:36+00:00</updated><id>https://rosemary-crypto.github.io/feed.xml</id><title type="html">Rosemary Koikara - Cryptography, Blockchain, and AI Enthusiast</title><subtitle>Personal site for blog, projects, cv, etc. </subtitle><entry><title type="html">Introduction to Secret Sharing</title><link href="https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing/" rel="alternate" type="text/html" title="Introduction to Secret Sharing"/><published>2024-08-20T15:12:00+00:00</published><updated>2024-08-20T15:12:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/introduction-to-secret-sharing/"><![CDATA[<h2 id="introduction-to-secret-sharing">Introduction to Secret Sharing</h2> <p>I wouldn’t call myself a secretive person, but I do value my privacy. If you’re like me, you’ve probably found yourself holding onto a secret so tightly that you start feeling like it might just burst out. But instead of spilling the whole thing to one person, you decide to share bits and pieces with different people. This way, no single person knows the full story, and you feel a bit more secure.</p> <p>Secret sharing works in a similar way. Introduced by Adi Shamir and George Blakley independently in 1979 (yes, it’s been around for a while, but like a good classic, it’s still relevant), secret sharing is all about distributing a secret among a group of participants. The twist? No single participant has any meaningful information on their own. However, when a sufficient number of these participants come together, they can reconstruct the original secret.</p> <p>In this post, we’ll explore Shamir’s version of secret sharing, a powerful cryptographic tool that splits a secret into pieces, or “shares.” These shares are individually useless, but when you have enough of them (we’ll call this number the threshold), you can piece together the original secret.</p> <h2 id="mathematical-definition-of-shamirs-secret-sharing">Mathematical Definition of Shamir’s Secret Sharing</h2> <p>Let’s get a bit more technical. SSS is sometimes referred to as the \((k, n)\) threshold secret sharing scheme. Here, \(n\) is the number of shares into which the secret is divided, and \(k\) is the minimum number of shares required to reconstruct the secret. Essentially, \(k\) participants must come together to unlock the secret. If you have fewer than \(k\) shares, you’re out of luck; the secret remains hidden.</p> <p>But how does this actually work? The secret is hidden inside a mathematical function called a polynomial. A polynomial is just a mathematical expression involving a sum of powers of \(x\) multiplied by coefficients. In Shamir’s scheme, we use a polynomial of degree \(k-1\), which ensures that any group of \(k\) or more participants can reconstruct the secret.</p> \[f(x) = s_0 + s_1x + \dots + s_{k-1}x^{k-1} \mod p\] <p>Lagrange’s interpolation can be used to reconstruct the secret. The Lagrange interpolation formula for reconstructing the polynomial (and thus the secret) from these shares is:</p> \[q(x) = \sum_{i=1}^{k} y_i \cdot L_i(x)\] <p>where \(y_i\) are the share values, and \(L_i(x)\) are the Lagrange basis polynomials, defined as:</p> \[L_i(x) = \prod_{\substack{1 \le j \le k \\ j \ne i}} \frac{x - x_j}{x_i - x_j}\] <h2 id="why-modular-arithmetic-and-prime-numbers">Why Modular Arithmetic and Prime Numbers?</h2> <ul> <li> <p><strong>Modular arithmetic</strong> is a system of arithmetic for integers, where numbers wrap around after they reach a certain value, \(p\) (the modulus). Think of it like a clock: after 12 comes 1 again. In cryptography, modular arithmetic helps keep numbers within a specific range, making it more manageable and secure.</p> </li> <li> <p><strong>Prime numbers</strong> are crucial because they ensure certain properties that are vital for cryptographic security:</p> <ul> <li><strong>Unique Inverses</strong>: In modular arithmetic with a prime modulus \(p\), every non-zero number has a unique multiplicative inverse. This means that for any non-zero number \(a\) within the range \([1, p-1]\), there exists a number \(b\) such that \((a \cdot b) \mod p = 1\). This property is crucial because it allows division operations to be performed in modular arithmetic.</li> <li><strong>Avoiding Redundancies</strong>: Prime moduli help avoid redundancies and ensure that every possible result of an operation is unique within the range \([0, p-1]\). This uniqueness is critical in cryptography because it prevents different numbers from being treated as equivalent, which could otherwise lead to vulnerabilities.</li> <li><strong>Mathematical Stability</strong>: Using a prime number ensures that the structure of the arithmetic remains stable, making it easier to predict and manage the behavior of calculations, which is why primes are often used in cryptographic protocols.</li> </ul> </li> </ul> <h2 id="basic-example-with-numbers">Basic Example with Numbers</h2> <p>Let’s start simple. Imagine you have a secret number, and you want to split it among five people so that any three of them can come together and recover it. You’ll create a polynomial, and each person gets a point on this polynomial as their share. Only when three or more people pool their points together can they figure out what the original number (the secret) was.</p> <h3 id="generating-the-shares">Generating the Shares</h3> <p>Let’s take a \((2, 5)\) threshold scheme to divide the secret 298 and let the prime number be 307. (I chose 307 since it is a prime number larger than 298)</p> <ol> <li><strong>Set up the polynomial</strong> <ul> <li>Degree: \(k-1 = 1\)</li> <li>Form: \(q(x) = s + a_1 \cdot x \mod p = 298 + a_1 \cdot x \mod 307\)</li> </ul> </li> <li> <p><strong>Choose a random coefficient</strong> \(a_1\) in the range \([0, p)\). Let’s choose \(a_1 = 123\).</p> </li> <li><strong>Calculate the shares</strong>: Now, we can calculate the shares at 5 non-zero points \(x = 1, 2, 3, 4, 5\) as: <ul> <li>Share 1: \((1, 114)\)</li> <li>Share 2: \((2, 237)\)</li> <li>Share 3: \((3, 53)\)</li> <li>Share 4: \((4, 176)\)</li> <li>Share 5: \((5, 299)\)</li> </ul> </li> </ol> <p>You now have 5 shares: \((1, 114), (2, 237), (3, 53), (4, 176), (5, 299)\).</p> <h3 id="reconstructing-the-secret-using-lagrange-interpolation">Reconstructing the Secret Using Lagrange Interpolation</h3> <p>Let’s now reconstruct the secret using Lagrange interpolation. Since this is a \((2, 5)\) threshold scheme, we need only two of the shares to reconstruct the secret. We’ll use Share 1 \((1, 114)\) and Share 2 \((2, 237)\).</p> <ol> <li><strong>Calculate the Lagrange basis</strong> <ul> <li>For our example, with \(x_1 = 1\) and \(x_2 = 2\), the Lagrange basis polynomials at \(x = 0\) (which gives us the secret) are:</li> </ul> \[L_1(0) = \frac{0 - 2}{1 - 2} = \frac{-2}{-1} = 2\] \[L_2(0) = \frac{0 - 1}{2 - 1} = \frac{-1}{1} = -1\] </li> <li><strong>Calculate the Secret</strong> <ul> <li>Now, we use these Lagrange basis polynomials to reconstruct the secret:</li> </ul> \[q(0) = y_1 \cdot L_1(0) + y_2 \cdot L_2(0)\] <ul> <li>Substituting the values from the shares:</li> </ul> \[q(0) = 114 \cdot 2 + 237 \cdot (-1) = 228 - 237 = -9\] <ul> <li>Since we’re working in modular arithmetic with \(p = 307\), we take the result modulo 307:</li> </ul> \[q(0) = -9 \mod 307 = 298\] </li> </ol> <p>Thus, the reconstructed secret is \(s = 298\), which matches our original secret.</p> <h2 id="shamirs-secret-sharing-using-a-secret-image">Shamir’s Secret Sharing Using a Secret Image</h2> <p>To really bring this to life, let’s take it a step further. Instead of just splitting a number, let’s split an image. Lets take an example of (3,5) threshold secret sharing as shown in the figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/secret_sharing/3_5_SecretImageSharing-480.webp 480w,/assets/img/secret_sharing/3_5_SecretImageSharing-800.webp 800w,/assets/img/secret_sharing/3_5_SecretImageSharing-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/secret_sharing/3_5_SecretImageSharing.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> ((3,5) Threshold Secret Image Sharing) </div> <h3 id="how-it-works">How It Works</h3> <ul> <li> <p><strong>Image Splitting</strong>: Each pixel’s grayscale value in the image is treated as a secret. Shamir’s Secret Sharing algorithm is applied to split each pixel’s value into multiple shares. For instance, in a \((3,5)\) threshold scheme, the image is divided into 5 shares, but at least 3 shares are needed to reconstruct the image.</p> </li> <li> <p><strong>Share Generation</strong>: For each pixel, shares are generated based on a random polynomial where the pixel value is the constant term. These shares are then distributed, with each share forming part of a different image, each appearing as random noise.</p> </li> <li> <p><strong>Image Reconstruction</strong>: To reconstruct the image, a minimum of 3 shares are combined using Lagrange interpolation to recover the original pixel values and, thus, the entire image.</p> </li> </ul> <h3 id="code-implementation">Code Implementation</h3> <p>The complete implementation of this concept is provided in the repository. The code is available in both C++ and Rust:</p> <ul> <li><strong>C++ Version</strong>: <ul> <li>Located in the <code class="language-plaintext highlighter-rouge">cpp_version</code> directory, this version uses OpenCV for image processing.</li> <li>Core files include <code class="language-plaintext highlighter-rouge">SecretSharing.hpp</code>, <code class="language-plaintext highlighter-rouge">SecretSharing.cpp</code>, and <code class="language-plaintext highlighter-rouge">main.cpp</code>.</li> </ul> </li> <li><strong>Rust Version</strong>: <ul> <li>Located in the <code class="language-plaintext highlighter-rouge">rust_version</code> directory, this version utilizes Rust’s <code class="language-plaintext highlighter-rouge">threshold_crypto</code> library.</li> <li>Key files include <code class="language-plaintext highlighter-rouge">main.rs</code>, <code class="language-plaintext highlighter-rouge">lib.rs</code>, and modules for share generation and reconstruction.</li> </ul> </li> </ul> <p>The code is accessible on <a href="https://github.com/rosemary-crypto/Shamir-sSecretSharing">GitHub</a> for further exploration and application.</p> <h2 id="significance-in-modern-applications">Significance in Modern Applications</h2> <p>Now, why should you care about this old-school cryptography trick? Well, let’s dive into the world of Threshold Signature Schemes (TSS). Imagine you’re working on a distributed system, like a blockchain. In such systems, it’s crucial that a group of participants can collaboratively sign off on transactions or documents. But here’s the catch: you don’t want any single participant holding the entire signing key, because that’s a single point of failure and a potential security nightmare.</p> <p>TSS comes to the rescue by allowing a group of participants to generate a digital signature on a message without anyone holding the full key. Instead, the key is distributed, and only a subset of participants—what we call the threshold number—needs to come together to produce a valid signature. This method not only enhances security by eliminating single points of failure but also builds trust, as no single party controls the entire signing process.</p> <p>However, TSS more complex than SSS, but that’s why we’re here. Before diving into TSS, it’s important to understand SSS and its limitations so we can appreciate the need for more advanced techniques like TSS.</p>]]></content><author><name></name></author><category term="cryptography"/><category term="cryptography,"/><category term="secret"/><category term="sharing,"/><category term="TSS"/><summary type="html"><![CDATA[An introduction to Shamir's Secret Sharing and its applications]]></summary></entry><entry><title type="html">Getting Started with GStreamer Development – A Beginner’s Guide</title><link href="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/" rel="alternate" type="text/html" title="Getting Started with GStreamer Development – A Beginner’s Guide"/><published>2024-08-14T23:00:00+00:00</published><updated>2024-08-14T23:00:00+00:00</updated><id>https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1</id><content type="html" xml:base="https://rosemary-crypto.github.io/blog/2024/build-with-gstreamer-Lesson-1/"><![CDATA[<style>.post-content h2{font-size:2rem;font-weight:600;color:#00543d;border-bottom:2px solid #00543d;padding-bottom:.5rem;margin-top:2rem;margin-bottom:1rem}.post-content h3{font-size:1.75rem;font-weight:500;color:#264653;margin-top:1.5rem;margin-bottom:.75rem}.post-content h4{font-size:1rem;font-weight:500;color:#e76f51;margin-top:1.25rem;margin-bottom:.5rem;margin-left:1.5rem}.post-content h4+*{margin-left:1.5rem}</style> <h2 id="introduction">Introduction</h2> <p>Around a year and a half ago, I found myself tasked with rebuilding an AI video analytics platform. The goal? To transition it to use the GStreamer framework. At first, it seemed like an insurmountable challenge. I spent countless nights grappling with GStreamer’s intricacies—confused by the difference between a sink and a source, haunted by the complexities of GStreamer buffers. But as I pushed through, I started to see the beauty in it. I can’t believe I’m saying this, but GStreamer has made me fall deeper in love with C and C++.</p> <p>In this guide, I’ll introduce you to the basics of GStreamer, sharing what I’ve learned along the way to help you get started with building your own multimedia applications. Let’s dive in!</p> <h3 id="what-is-gstreamer">What is GStreamer?</h3> <p>GStreamer is a powerful multimedia framework used for building media processing pipelines. Whether you’re dealing with video, audio, or any other type of media, GStreamer provides the tools you need to manipulate and process data efficiently.</p> <p>At its core, GStreamer is built around the concept of pipelines—sequences of elements that process data from one end to another. These elements can be sources (e.g., reading from a file), filters (e.g., converting formats), or sinks (e.g., outputting to a display or speaker). Think of it as a factory assembly line, where raw materials (your media) are processed and refined at various stations (the elements), eventually leading to a finished product (your output).</p> <h3 id="what-am-i-using-gstreamer-for">What Am I Using GStreamer For?</h3> <p>For my AI video analytics platform, GStreamer acts as the backbone. The simplest version of the process is relatively straightforward: reading from a source (whether that’s video files, RTSP streams, etc.), performing object detection, tracking, and finally displaying the results. However, the full platform involves much more. It includes decoding the video streams, pre-processing the data, performing advanced object detection and tracking, video classification, adding custom metadata, sending data over MQTT, streaming via RTSP, and even detecting specific events. This complex pipeline allows for real-time analytics and decision-making, making GStreamer an essential tool in building this robust and scalable solution.</p> <p>You might wonder, “Why not just use something like NVIDIA’s DeepStream SDK?” It’s a valid question, and honestly, DeepStream could simplify things. But where’s the fun in that? GStreamer is open-source, allowing me to tweak and modify the code as needed. When existing plugins don’t meet my requirements, I have the freedom to build my own. This series is about giving you that same power: developing your own custom GStreamer elements for Linux, Windows, and macOS. So, let’s continue with the basics.</p> <h2 id="the-set-up">The Set-Up</h2> <h3 id="how-do-you-start">How Do You Start?</h3> <p>There’s no better place to understand GStreamer concepts than by exploring the <a href="https://gstreamer.freedesktop.org/documentation/application-development/?gi-language=c">GStreamer Application Development Manual</a>. It’s a treasure trove of information, and while I won’t repeat the concepts here, I’ll guide you through navigating everything, making your learning process smoother.</p> <h3 id="installing-gstreamer">Installing GStreamer</h3> <p>Before diving into examples, you’ll need to install GStreamer on your system. I suggest following the installation instructions in the <a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">GStreamer Application Development Manual</a> for your specific environment, whether that’s Linux, Windows, or macOS.</p> <h2 id="creating-a-simple-pipeline">Creating a Simple Pipeline</h2> <p>To understand GStreamer, it’s crucial to get hands-on experience. Let’s start by creating a simple pipeline to display a video.</p> <h3 id="pipeline-diagram">Pipeline Diagram</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-480.webp 480w,/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-800.webp 800w,/assets/img/build_with_gstreamer/basic-pipeline-lesson-1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/build_with_gstreamer/basic-pipeline-lesson-1.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This diagram shows a simple pipeline with elements like <code class="language-plaintext highlighter-rouge">filesrc</code>, <code class="language-plaintext highlighter-rouge">decodebin</code>, and <code class="language-plaintext highlighter-rouge">autovideosink</code> connected together.</p> <h3 id="understanding-the-basics">Understanding the Basics</h3> <ul> <li><strong>Elements:</strong> These are the basic building blocks of a GStreamer pipeline. Each element has a specific role, such as reading data (source), processing it (filter), or outputting it (sink). For example: <ul> <li><code class="language-plaintext highlighter-rouge">filesrc</code>: Reads data from a file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the data.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> </ul> </li> <li> <p><strong>Pads:</strong> A pad is a point of connection in a GStreamer element, where media data flows in or out. Every element has two types of pads: source pads (where data exits the element) and sink pads (where data enters). This concept mirrors real-world scenarios—a water faucet (source) provides water, while a drain (sink) receives it.</p> </li> <li> <p><strong>Bins:</strong> A bin is a container for elements. It groups multiple elements together, managing them as a single entity. This is particularly useful when dealing with complex pipelines. For example, <code class="language-plaintext highlighter-rouge">decodebin</code> is a bin because it automatically detects the format of incoming data, creates the necessary elements to decode it, and manages them internally. You don’t have to worry about what’s inside; it’s like a black box that simplifies your pipeline design.</p> </li> <li><strong>Pipelines:</strong> A pipeline is a special type of bin that manages the flow of data between elements. It controls the state of the elements and ensures data flows correctly from source to sink. Pipelines can contain multiple elements and bins, working together to process and deliver media.</li> </ul> <h3 id="command-line">Command Line</h3> <p>Let’s create the pipeline shown in the diagram using GStreamer’s command-line tool:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gst-launch-1.0 filesrc <span class="nv">location</span><span class="o">=</span>/path/to/video.mp4 <span class="o">!</span> decodebin <span class="o">!</span> autovideosink
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">filesrc location=/path/to/video.mp4</code>: This element reads the video file.</li> <li><code class="language-plaintext highlighter-rouge">decodebin</code>: Automatically detects and decodes the video format.</li> <li><code class="language-plaintext highlighter-rouge">autovideosink</code>: Displays the video on your screen.</li> <li><code class="language-plaintext highlighter-rouge">gst-launch-1.0</code>: A command-line tool provided by GStreamer to run pipelines.</li> <li><code class="language-plaintext highlighter-rouge">!</code>: Links elements together within the pipeline.</li> </ul> <h3 id="writing-the-equivalent-gstreamer-application-in-c">Writing the Equivalent GStreamer Application in C++</h3> <p>While using the command line is great for quick tests, writing your own applications using GStreamer’s API is where the real fun begins. Below is the part of the code to create a basic video player in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">GMainLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">;</span>
    <span class="n">GstBus</span><span class="o">*</span> <span class="n">bus</span><span class="p">;</span>
    <span class="n">guint</span> <span class="n">bus_watch_id</span><span class="p">;</span>

    <span class="c1">// Initialize GStreamer</span>
    <span class="n">gst_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

    <span class="c1">// Create a main loop, which will run until we explicitly quit</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">g_main_loop_new</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

    <span class="c1">// Create the elements</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">gst_pipeline_new</span><span class="p">(</span><span class="s">"video-player"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">source</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"filesrc"</span><span class="p">,</span> <span class="s">"file-source1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"decodebin"</span><span class="p">,</span> <span class="s">"decode-bin1"</span><span class="p">);</span>
    <span class="n">GstElement</span><span class="o">*</span> <span class="n">autovideosink</span> <span class="o">=</span> <span class="n">gst_element_factory_make</span><span class="p">(</span><span class="s">"autovideosink"</span><span class="p">,</span> <span class="s">"video-output1"</span><span class="p">);</span>

    <span class="c1">// Check that all elements were created successfully</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipeline</span> <span class="o">||</span> <span class="o">!</span><span class="n">source</span> <span class="o">||</span> <span class="o">!</span><span class="n">decoder</span> <span class="o">||</span> <span class="o">!</span><span class="n">autovideosink</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Not all elements could be created.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the source file location</span>
    <span class="n">g_object_set</span><span class="p">(</span><span class="n">G_OBJECT</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s">"location"</span><span class="p">,</span> <span class="s">"../resources/videos/big_buck_bunny_scene.mp4"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Add all elements to the pipeline</span>
    <span class="n">gst_bin_add_many</span><span class="p">(</span><span class="n">GST_BIN</span><span class="p">(</span><span class="n">pipeline</span><span class="p">),</span> <span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">autovideosink</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Link the source to the decoder (decoder will dynamically link to sink)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gst_element_link</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">decoder</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Source and decoder could not be linked.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">pipeline</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Connect the pad-added signal for the decoder</span>
    <span class="n">g_signal_connect</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="s">"pad-added"</span><span class="p">,</span> <span class="n">G_CALLBACK</span><span class="p">(</span><span class="n">on_pad_added</span><span class="p">),</span> <span class="n">autovideosink</span><span class="p">);</span>

    <span class="c1">// Set the pipeline to the playing state</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_PLAYING</span><span class="p">);</span>

    <span class="c1">// Start the main loop and wait until it is quit (e.g., via EOS or an error)</span>
    <span class="n">g_main_loop_run</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="c1">// Clean up: set the pipeline to NULL state, remove bus watch, and unref</span>
    <span class="n">gst_element_set_state</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">GST_STATE_NULL</span><span class="p">);</span>
    <span class="n">gst_object_unref</span><span class="p">(</span><span class="n">GST_OBJECT</span><span class="p">(</span><span class="n">pipeline</span><span class="p">));</span>
    <span class="n">g_main_loop_unref</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Callback function to dynamically link pads</span>
<span class="kt">void</span> <span class="nf">on_pad_added</span><span class="p">(</span><span class="n">GstElement</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">GstPad</span><span class="o">*</span> <span class="n">new_pad</span><span class="p">,</span> <span class="n">GstElement</span><span class="o">*</span> <span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GstPad</span><span class="o">*</span> <span class="n">sink_pad</span> <span class="o">=</span> <span class="n">gst_element_get_static_pad</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="s">"sink"</span><span class="p">);</span>

    <span class="c1">// Check if the sink pad is already linked</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gst_pad_is_linked</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Attempt to link the newly created pad with the sink pad</span>
    <span class="n">GstPadLinkReturn</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">gst_pad_link</span><span class="p">(</span><span class="n">new_pad</span><span class="p">,</span> <span class="n">sink_pad</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GST_PAD_LINK_FAILED</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_printerr</span><span class="p">(</span><span class="s">"Type is '%s' but link failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">gst_structure_get_name</span><span class="p">(</span><span class="n">gst_caps_get_structure</span><span class="p">(</span><span class="n">gst_pad_get_current_caps</span><span class="p">(</span><span class="n">new_pad</span><span class="p">),</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">sink_pad</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">gst_init</code>: Initializes GStreamer and parses any command-line arguments.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_factory_make</code>: Creates the elements used in the pipeline, such as the source, decoder, and video sink.</li> <li><code class="language-plaintext highlighter-rouge">gst_bin_add_many</code>: Adds all elements to the pipeline.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_link</code>: Links the source element to the decoder. The decoder will dynamically link to the video sink when it determines the correct format.</li> <li><code class="language-plaintext highlighter-rouge">g_signal_connect</code>: Connects the “pad-added” signal for the decoder, allowing the new pad to be linked to the sink dynamically.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to PLAYING to start processing and displaying the video.</li> <li><code class="language-plaintext highlighter-rouge">g_main_loop_run</code>: Runs the main loop, keeping the application alive until an error occurs or the video finishes.</li> <li><code class="language-plaintext highlighter-rouge">gst_element_set_state</code>: Sets the pipeline’s state to NULL, stopping all elements when finished.</li> <li><code class="language-plaintext highlighter-rouge">gst_object_unref</code>: Frees up resources when the application is done.</li> </ul> <h4 id="understanding-the-on_pad_added-function">Understanding the <code class="language-plaintext highlighter-rouge">on_pad_added</code> Function</h4> <p>In GStreamer, some elements, like <code class="language-plaintext highlighter-rouge">decodebin</code>, dynamically create pads during runtime based on the media stream they are processing. They can’t link all their pads at the beginning because they don’t know what streams they will encounter (e.g., a video file might contain both audio and video streams).<br/> The <code class="language-plaintext highlighter-rouge">on_pad_added</code> function is a callback that gets triggered when the <code class="language-plaintext highlighter-rouge">decodebin</code> element adds a new pad. This is crucial because you need to link this newly created pad to the next element in your pipeline (in this case, <code class="language-plaintext highlighter-rouge">autovideosink</code>), which handles the video output.</p> <p>The complete code and detailed explanations, including installation instructions and how to run the program, are available on <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub</a>. This repository will be updated with each article in the series, making it easier for you to follow along.</p> <h3 id="github-repository-and-following-along">GitHub Repository and Following Along</h3> <p>To make the learning process even more interactive, I’ve created a <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a> where you can find all the code examples discussed in this series. Each module in this tutorial will be represented by a separate branch in the repository, allowing you to check out the specific branch to follow along with that module. As the course progresses, the <code class="language-plaintext highlighter-rouge">master</code> branch will be updated with the latest version of the project.</p> <ul> <li><strong>Start with Module 1:</strong> Check out the branch <code class="language-plaintext highlighter-rouge">lesson-1-getting-started</code> to see the code and examples for this introductory lesson.</li> <li><strong>Stay Updated:</strong> As you progress through the series, switch to the corresponding branch for each module to get the most relevant code and updates.</li> <li><strong>Explore the Code:</strong> Feel free to explore, modify, and experiment with the code in each branch to reinforce your learning.</li> </ul> <h3 id="compiling-and-running">Compiling and Running</h3> <p>Save the code to a file named <code class="language-plaintext highlighter-rouge">simple_player.cpp</code>. Then, compile it using <code class="language-plaintext highlighter-rouge">gcc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc simple_player.cpp <span class="nt">-o</span> simple_player <span class="si">$(</span>pkg-config <span class="nt">--cflags</span> <span class="nt">--libs</span> gstreamer-1.0<span class="si">)</span>
</code></pre></div></div> <p>Finally, run the compiled program:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./simple_player
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>This guide has introduced you to the basics of GStreamer, from understanding its architecture to creating a simple pipeline and writing a basic video player in C++. GStreamer is a powerful tool for multimedia development, offering the flexibility to build both simple and complex media applications.</p> <p>In the upcoming articles, we’ll explore GStreamer plugins in greater detail, including how to develop custom plugins for your specific needs—whether you’re aiming to build a media player, a streaming server, or an AI video analytics platform.</p> <h3 id="next-steps">Next Steps</h3> <ul> <li><strong>Access the Code:</strong> All the code examples, detailed explanations, and installation instructions are available in the <a href="https://github.com/rosemary-crypto/build-with-gstreamer">GitHub repository</a>. Make sure to check it out to follow along with each article in the series.</li> <li><strong>Experiment:</strong> Try experimenting with different GStreamer elements and building more complex pipelines.</li> <li><strong>Explore the Documentation:</strong> Dive into the GStreamer documentation to explore additional features and plugins.</li> <li><strong>Stay Tuned:</strong> Look forward to the next article, where we’ll discuss GStreamer plugins and how they work.</li> </ul>]]></content><author><name></name></author><category term="tutorials"/><category term="GStreamer,"/><category term="development,"/><category term="C++,"/><category term="AI,"/><category term="video"/><category term="analytics"/><summary type="html"><![CDATA[An introduction to GStreamer for building multimedia applications.]]></summary></entry></feed>